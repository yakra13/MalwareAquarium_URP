using System.Collections.Generic;
//using System.Drawing;
using UnityEngine;

public class Boid : MonoBehaviour
{
    //[SerializeField] BoidSettings settings;

    [HideInInspector] public Vector3 position;
    [HideInInspector] public Vector3 forward;
    Vector3 velocity;

    //Vector3 acceleration;
    [HideInInspector] public Vector3 avgFlockHeading;
    [HideInInspector] public Vector3 avgAvoidanceHeading;
    [HideInInspector] public Vector3 centreOfFlockmates;
    [HideInInspector] public int numPerceivedFlockmates;

    //Material material;
    Transform cachedTransform;
    Transform currentTarget;
    List<Transform> targets;

    [HideInInspector] public BoidDataObject boidData;

    public Transform CurrentTarget { get { return currentTarget; } set { currentTarget = value; } }
    public List<Transform> Targets { set { targets = value; } }

    public List<BoidSpawner> SpawnLocations;

    public float MaxBoredom { get { return boidData.maxBoredom; } }
    public float BoredomRatePerSecond { get { return boidData.boredomRatePerSecond; } }
    public float MaxFullness { get { return boidData.maxFullness; } }
    public float HungerRatePerSecond { get { return boidData.hungerRatePerSecond; } }
    public float MaxHealth { get { return boidData.maxHealth; } }

    void Awake()
    {
        //material = transform.GetComponentInChildren<MeshRenderer>().material;
        cachedTransform = transform;
    }

    /// <summary>
    /// Initialize the starting values for velocity, position, and forward.
    /// </summary>
    public void Initialize()
    {
        position = cachedTransform.position;
        forward = cachedTransform.forward;

        float startSpeed = (boidData.minSpeed + boidData.maxSpeed) / 2;
        velocity = transform.forward * startSpeed;
    }

    //public void Initialize(BoidSettings settings, Transform target)
    //{

    //    //this.settings = settings;
    //    //this.target = target;

    //    position = cachedTransform.position;
    //    forward = cachedTransform.forward;

    //    //TODO: alter speed caps
    //    float startSpeed = (settings.minSpeed + settings.maxSpeed) / 2;
    //    velocity = transform.forward * startSpeed;
    //}

    //public void SetColour(Color col)
    //{
    //    if (material != null)
    //    {
    //        material.color = col;
    //    }
    //}

    public void UpdateBoid()
    {
        Vector3 acceleration = Vector3.zero;

        if (currentTarget != null)
        {
            Vector3 offsetToTarget = (currentTarget.position - position);
            acceleration = SteerTowards(offsetToTarget) * boidData.targetWeight;
        }

        if (numPerceivedFlockmates != 0)
        {
            centreOfFlockmates /= numPerceivedFlockmates;

            Vector3 offsetToFlockmatesCentre = (centreOfFlockmates - position);

            Vector3 alignmentForce = SteerTowards(avgFlockHeading) * boidData.alignWeight;
            Vector3 cohesionForce = SteerTowards(offsetToFlockmatesCentre) * boidData.cohesionWeight;
            Vector3 seperationForce = SteerTowards(avgAvoidanceHeading) * boidData.seperateWeight;

            acceleration += alignmentForce;
            acceleration += cohesionForce;
            acceleration += seperationForce;
        }

        if (IsHeadingForCollision())
        {
            //Debug.Log("IS HEADING FOR COLLISION");
            Vector3 collisionAvoidDir = ObstacleRays();
            Vector3 collisionAvoidForce = SteerTowards(collisionAvoidDir) * boidData.avoidCollisionWeight;
            acceleration += collisionAvoidForce;
        }

        velocity += acceleration * Time.deltaTime;
        float speed = velocity.magnitude;
        Vector3 dir = velocity / speed;
        speed = Mathf.Clamp(speed, boidData.minSpeed, boidData.maxSpeed);
        velocity = dir * speed;

        cachedTransform.position += velocity * Time.deltaTime;
        cachedTransform.forward = dir;
        position = cachedTransform.position;
        forward = dir;
    }

    bool IsHeadingForCollision()
    {
        RaycastHit hit;
        if (Physics.SphereCast(position, boidData.boundsRadius, forward, out hit, boidData.collisionAvoidDst, boidData.obstacleMask))
        {
            //Debug.Log($"{boidData.displayName} is heading for collision");
            return true;
        }
        else
        {
        }
            
        return false;
    }

    Vector3 ObstacleRays()
    {
        Vector3[] rayDirections = BoidHelper.directions;

        for (int i = 0; i < rayDirections.Length; i++)
        {
            Vector3 dir = cachedTransform.TransformDirection(rayDirections[i]);
            Ray ray = new Ray(position, dir);
            if (!Physics.SphereCast(ray, boidData.boundsRadius, boidData.collisionAvoidDst, boidData.obstacleMask))
            {
                
                return dir;
            }
        }

        return forward;
    }

    Vector3 SteerTowards(Vector3 vector)
    {
        Vector3 v = vector.normalized * boidData.maxSpeed - velocity;
        return Vector3.ClampMagnitude(v, boidData.maxSteerForce);
    }

    /// <summary>
    /// Change to a new random target from BoidManager.Targets.
    /// </summary>
    /// <param name="forced">Forces the random target to not be the current target.</param>
    /// <returns>Returns false if no new target was available.</returns>
    public bool ChangeTargetRandom(bool forced = true)
    {
        //Debug.Log("Changing targets");
        if (targets.Count <= 1)
            return false;

        int newTargetIndex;
        
        do
            newTargetIndex = Random.Range(0, targets.Count);
        while (forced && CurrentTarget == targets[newTargetIndex]);

        CurrentTarget = targets[newTargetIndex];

        return true;
    }

    public BoidSpawner GetRandomSpawnLocation()
    {
        return SpawnLocations[Random.Range(0, SpawnLocations.Count - 1)];
        //Vector3 pos = spawner.transform.position + Random.insideUnitSphere * spawner.spawnCollider.radius / 2f;
        //return pos;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="targetName"></param>
    /// <returns></returns>
    public bool ChangeTargetByName(string targetName)
    {

        return true;
    }

    private void OnDrawGizmos()
    {
        Gizmos.color = Color.cyan;
        Gizmos.DrawWireSphere(transform.position, boidData.boundsRadius);

        Gizmos.color = Color.yellow;
        Vector3 sphereCastMidpoint = transform.position + (transform.forward * (boidData.collisionAvoidDst - boidData.boundsRadius));
        Gizmos.DrawWireSphere(sphereCastMidpoint, boidData.boundsRadius);
        Debug.DrawLine(transform.position, sphereCastMidpoint, Color.yellow);
    }
}
