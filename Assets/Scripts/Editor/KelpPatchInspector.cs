using System.Collections.Generic;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(KelpPatch))]
public class KelpPatchInspector : Editor
{
    SerializedProperty width;
    SerializedProperty length;


    KelpPatch script;
    GameObject gameObject;

    private void OnEnable()
    {
        width = serializedObject.FindProperty("width");
        length = serializedObject.FindProperty("length");

        script = (KelpPatch)target;
        gameObject = script.gameObject;

        
    }

    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        serializedObject.UpdateIfRequiredOrScript();

        EditorGUILayout.PropertyField(width, new GUIContent("Patch Width"));
        EditorGUILayout.PropertyField(length, new GUIContent("Patch Length"));

        //script.width = EditorGUILayout.IntField("Patch Width", script.width);

        if (GUILayout.Button("Generate"))
        {
            Generate();
        }

        serializedObject.ApplyModifiedProperties();
    }
    //private void Update()
    //{
    //    if (generate)
    //        Generate();
    //}

    //This could probably be in KelpPatch...
    private void Generate()
    {
        for (int i = gameObject.transform.childCount - 1; i >= 0; i--)
        {
            DestroyImmediate(script.transform.GetChild(i).gameObject);
        }
        //grid the area->allow for 2x2 square for each kelp
        //int[,] grid = new int[width / 2, length / 2];
        //pick starting point randomly that is in a valid position (ray cast)
       
        //TODO:could take into account the rotation

        Transform t = gameObject.transform;

        for (int i = 0; i < script.density; i++)
        {
            Vector3 v = new Vector3(Random.Range(t.position.x - script.width / 2f, t.position.x + script.width / 2f),
                                    t.position.y,
                                    Random.Range(t.position.z - script.length / 2f, t.position.z + script.length / 2f));
            RaycastHit r;
            if (Physics.Raycast(v, Vector3.down, out r, 100f, script.layerMask))
            {
                GameObject kelp = Instantiate(script.kelpPrefabs[Random.Range(0, script.kelpPrefabs.Count)], t);
                kelp.transform.position = r.point;
                //Debug.Log($"kelp positiont: {kelp.transform.position}");
                float left = gameObject.transform.position.x + script.width / 2;
                float xScale = Mathf.Abs(kelp.transform.position.x - left) / script.width;
                //Debug.Log($"left to right: {xScale}");
                xScale = script.widthProfile.Evaluate(xScale);
                //Debug.Log($"height: {xScale}");

                float front = gameObject.transform.position.z + script.length / 2;
                float yScale = Mathf.Abs(kelp.transform.position.z - front) / script.length;
                yScale = script.lengthProfile.Evaluate(yScale);
                //Y scale is on Z cuz export mess up import mess up yada yada
                float scaleFactor = xScale * yScale;
                float xyScale = Mathf.Clamp(scaleFactor, 0.1f, 1f);
                kelp.transform.localScale = new Vector3(xyScale, xyScale, scaleFactor);// Random.Range(-script.minHeightMod, script.maxHeightMod));
            }

        }
    }



}
